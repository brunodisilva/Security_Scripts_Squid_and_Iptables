#!/bin/sh  
# 
# Iptables firewall script by netcat, <root@the-devil.dnsalias.net> 
# 
# This script is for a single host with cable connection 
# You have been warned, this is my *paranoid* set of firewall rules, it works fine for me, it may not work properly for others, so beware.... use at your own risk!
#
# 22-07-2002 - added basic() option, ipv4options module
# 26-07-2002 - added established connections logging option to open tcp ports, removed ip_queue module (not used)
# 11-08-2002 - updated icmp logging (with iptables 1.2.7 "-p icmp -j LOG" was logging by default icmp echo-reply), removed the two rules "--ttl-inc" and "--ttl-dec", keeping the "--ttl-set", removed "log ALL connection attempts (all packets except ICMP)", the pkttype module does the job, removed xconsole monitoring; (tail -f /var/log/messages > /dev/console &; xconsole -exitOnFail &), USE SWATCH! 
# 21-08-2002 - updated IANA ipv4 address space
# 23-08-2002 - blocked host(s) rules are now inserted at the head of the INPUT and OUTPUT chains, btw; USE PORTSENTRY!, removed logging of established connections to open ports, wanna log all stuff? use SNORT!   
# 26-08-2002 - minor tweak in basic() option
# 31-08-2002 - there is now 3 different scripts; extremist (this one), extremist6 (ipv6) and extremist2 (both ipv4 and ipv6) 
# 02-09-2002 - added 2 scripts; "Protecting your host from SYN floods" and "Ratelimit ICMP to prevent dDoS", shameless stollen from the Linux Advanced Routing & Traffic Control HOWTO @ http://lartc.org, updated IANA ipv4 address space again 
# 08-09-2002 - every LOG rule follows a DROP rule, (repetitive=yes, more secure=yes) 
# 21-09-2002 - changed some echoes to printf
# 24-09-2002 - added "The cat" logo, removed the l33t cow  
# 25-09-2002 - ups, something I've forgot; if the script is reloaded while the lartc SYN flood script is on, the iptables Mark rule is lost, please check that in "dstat" ->iptables SYN tag, removed extremist2 (ipv4 and ipv6), ip6tables script @ http://the-devil.dnsalias/home/extremist6
# 15-10-2002 - updated IANA ipv4 address space again
# 16-10-2002 - the ipt_unclean module has already dropped legitimate connections here, enable at your own risk!
# 17-10-2002 - added logging of -m ipv4options --no-srr (pure log flood *g*), added ToS option to tcp port 53
# 22-10-2002 - well..., the "DROP" word in every log prefix is just for the swatch/wots fun, (http://www.oit.ucsb.edu/~eta/swatch/), (http://www.tony-curtis.cwc.net/tools/)  just use it, happy logging! 
#in /root/.swatchrc
# watchfor /DROP/
#          echo bold
#          bell
# mail root@the-devil=alert,subject=--- Iptables Firewall Alert ---
#
#in /root/.wotsrc
# from /var/log/messages
# /DROP/				echo=blink;on_blue,bell,mail 
#
# 26-10-2002 - added ipt_psd module (Portscan detection match), added checking of all netfilter extension modules, removed lartc scripts (plz use it in a separate script)
# 27-10-2002 - added ipt_string module (packet string match), updated IANA ipv4 address space again 
# 11-11-2002 - added a optional rule to limit the number of parallel connections made by group hosts using mask, added "-m state --state ESTABLISHED" to string match rules
# 14-11-2002 - added ipt_MIRROR module 
# 17-11-2002 - added TTL_SET variable, basic() option now tries to remove all unnused modules
# 28-12-2002 - added time match module
# 29-12-2002 - removed CLOSEDTCPLOG and CLOSEDUDPLOG variables (not really needed)
# 03-01-2003 - updated IANA ipv4 address space again
# 04-01-2003 - added DROP/REJECT target option to string match packets
# 11-01-2003 - added DROP/REJECT/TARPIT target option to string match packets, added fuzzy match rules, added IPLIMIT variable 
# 12-01-2003 - start() and reload() options also tries to remove all unnused modules, more comments added, placed fragmented packet and illegal tcp flags/options rules before connection tracking 
# 13-01-2003 - added OWNER variable
# 25-01-2003 - added lartc scripts again, http://the-devil.dnsalias.net/home/lartc
# 31-01-2003 - minor tweak in basic() option, to spoof or not to spoof... complete freedom to send all types of packets to outside, removed "all except icmp echo reply" to icmp logging option, this was a workaround for iptables version 1.2.7 see #11-08-2002
# 16-02-2003 - since all unnused modules are removed after start() and reload() functions, IRC and FTP variables are required 
# 21-02-2003 - removed IRC and FTP variables, added RELATED variable for the related packets connection tracking  
# 05-07-2003 - added logging of all IANA reserved an private ip addresses on network interface, warning: ipt_iplimit module is now known as ipt_connlimit (iptables v1.2.8-20030701), added ipt_connbytes module
# 06-07-2003 - added ipt_iprange module, updated IANA Reserved and Special-Use IPv4 addresses
# 19-08-2003 - added BLOCKNET/BLOCKNETLOG variables
# 20-08-2003 - more /proc entries stuff
# 10-10-2003 - added tcp_synack_retries /proc entry 
# 13-10-2003 - added PKT_TYPE and IPV4_OPTIONS variables
# 03-12-2003 - added cat() function
# 07-12-2003 - the script shrunk a bit
# 08-12-2003 - OWNER var removed
# 09-12-2003 - PKTTYPE, IPV4, CONNBYTES var's removed
# 17-12-2003 - added TRUST_HOST option, for a trusted remote host tcp port access
# 27-12-2003 - IANA Reserved ipv4-address-space update
# 23-01-2004 - added decrement rule before the MIRROR rule (http://www.netfilter.org/security/2001-08-22-mirror.html), added psd params 
# 19-06-2004 - IANA Reserved ipv4-address-space update

################################################################################
# Configuration options
ipt() 
{
/usr/local/sbin/iptables "$@" #location of iptables
}                                                                            
INT="eth0"         #network interface                  
LOOP="lo"          #loopback device               
LOGLEVEL="info"      #loglevel (see man syslogd)  
FPACKLOG="y"         #log and drop fragmented packets (use "y" to enable, anything else to disable)          
BADTCPLOG="y"        #log and drop illegal tcp flags/options (...) 
IPACKLOG="y"         #log and drop invalid packets (...)   
MPACKLOG="y"         #log and drop malformed packets (...) 
NNSYNLOG="n"         #log and drop new packets with no syn flag set (...)   
ICMPLOG="y"          #log and drop icmp packets (...) 
IGMPLOG="y"          #log and drop igmp packets (...) 
PSD="y"              #log and drop portscan detection match packets (...)
STRING="n"           #log and drop/reject/tarpit string match packets, (use "d" to DROP, "r" to REJECT, "t" to TARPIT, anything else to disable)
TIME="n"             #log and drop outgoing time match packets (...)
FUZZY="n"            #log and drop fuzzy match packets (...)
RELATED="y"          #accept related firewall seen connections, load ip_conntrack_ftp module, ip_conntrack_irc module (...)
IANA="y"             #log all IANA private and reserved ips connection attempts on network interface (...)
MANGLE="y"           #mangle packets (...) 

# Explicitly blocked ports (for logging purposes)  
CLOSEDTCP=" "         
CLOSEDUDP=" "

# There is no point in enabling this if you don't have a bug free properly configured tight secured chrooted server to put here and/or in the QUOTA options bellow, else, you don't need any firewall at all, you are doomed! *g* 
# Open ports/services to the WWW 
OPEN_TCP="25 80"    
OPEN_UDP=" "

# Open ports/services to the WWW, with a quota limit of incoming "n"Megs, when the quota is reached, the rule doesn't match anymore. Ex; 1Meg=1048576, 2Megs=echo $[1048576 * 2], etc...
QUOTA=2097152
OPEN_TCP_QUOTA=" " 
OPEN_UDP_QUOTA=" "

# Match if the number of existing tcp connections is not above n (to open tcp ports/services to the WWW)
LIMIT="2"
 
# Explicitly blocked host(s) with no access to this box, even to the ports/services open to the WWW /Log connection attempts? y/n 
BLOCKHOSTS=" " 
BLOCKHOSTSLOG="n"  

# Explicitly blocked networks with no access to this box, even to the ports/services open to the WWW (ex: use 81.86.0.0/16 instead of 81.86/16) /Log connection attempts? y/n
BLOCKNET=" " 
BLOCKNETLOG="n"

# Network interface ip address          
IP_ADDR=`/sbin/ifconfig $INT | grep inet | cut -d : -f 2 | cut -d \  -f 1`  

# Deny access to the WWW to some lame user (uid), in this box  
LAME_USER=" "
LAME_UID=`/usr/bin/id -u $LAME_USER`    

# String match configuration 
STRINGS="/default.ida? .exe?/c+dir"
STRING_TCP_PORT="80"
# If "STRING=r", send back an error packet in response to the matched packet, (options: iptables -j REJECT -h) 
REJECT="tcp-reset"

# This is used to bounce back the packet to the sender, it can be as funny as hell or a big headache...
# Mirror tcp port(s)
MIRROR_TCP_PORT=" "

# Set the TTL (Time To Live) of all outgoing connections to... 
TTL_SET="69"

# Time match configuration...
TIMESTART="07:00"
TIMESTOP="02:10"
DAYS="Sat,Sun,Mon,Tue,Wed,Thu,Fri"

# Fuzzy match configuration...
LOWER="300"
UPPER="1000"

# Connbytes match configuration... FROM:[TO] (ex: "200000:400000")
CONN=" "

# Iprange match configuration... (ex: "123.233.5.45-123.234.1.124")
IPRANGE=" "

# Ipv4options match configuration... (options: iptables -m ipv4options -h)
IPV4_OPTIONS=" "

# Packet type match configuration... (options: iptables -m pkttype -h)
PKT_TYPE=" "

# Trust this host? 
TRUST_HOST=" "
# The remote host will access to witch tcp port?
TH_TCP_PORT=" "

# Path to lartc scripts
LARTC="/home/ant/files/lartc"

################################################################################
# You must be rOOt to run this script!
ROOT_UID=0
if [ "$UID" -eq "$ROOT_UID" ]
 then
   :
 else
printf '\033[1;60mare you rOOt ?!? \033[0m\n'
   exit 1
fi

cat () {
# http://www.ascii-fr.com/animaux_chats.html
# Quoting nightmare *g*
printf "\033[1;60m                        _      \033[0m\n"
printf "\033[1;60m                        \\\`\\ \033[0m\n"   
printf "\033[1;60m             /./././.   | |    \033[0m\n" 
printf "\033[1;60m           /        \`/. | |   \033[0m\n" 
printf "\033[1;60m          /     __    \`/\'/\' \033[0m\n" 
printf "\033[1;60m       /\\__/\\ /\\'  \`\    / \033[0m\n" 
printf "\033[1;60m      |  oo  |      \`.,.|     \033[0m\n"  
printf "\033[1;60m       \\\vvvv/        ||||    \033[0m\n"  
printf "\033[1;60m         ||||        ||||      \033[0m\n"  
printf "\033[1;60m         ||||        ||||      \033[0m\n"    
printf "\033[1;60m         \`'\`'        \`'\`'  \033[0m\n" 
}

start () { 
  cat
# Modprobe iptables modules 
MODULES="ip_tables iptable_filter iptable_mangle iptable_nat ip_conntrack ipt_limit ipt_state ipt_LOG ipt_TCPMSS ipt_TOS"  
if [ -f /lib/modules/`uname -r`/kernel/net/ipv4/netfilter/ip_tables.o ] 
 then
/sbin/modprobe $MODULES             
 else
  echo "Oops! No iptables modules found..." 
fi

# Clear previous rules
ipt -F 
ipt -Z
ipt -X
ipt -F -t nat 
ipt -Z -t nat
ipt -X -t nat
ipt -F -t mangle
ipt -Z -t mangle
ipt -X -t mangle 

# Set the chains  
ipt -P INPUT DROP
ipt -P FORWARD DROP
ipt -P OUTPUT DROP
ipt -t nat -P PREROUTING ACCEPT
ipt -t nat -P POSTROUTING ACCEPT
ipt -t nat -P OUTPUT ACCEPT
ipt -t mangle -P PREROUTING ACCEPT 
ipt -t mangle -P OUTPUT ACCEPT
ipt -t mangle -P INPUT ACCEPT 2>/dev/null >/dev/null
ipt -t mangle -P FORWARD DROP 2>/dev/null >/dev/null
ipt -t mangle -P POSTROUTING ACCEPT 2>/dev/null >/dev/null 

# In loopback we trust
for i in $LOOP; do
ipt -A INPUT -i $i -j ACCEPT
ipt -A OUTPUT -o $i -j ACCEPT
done

# /proc/sys/net networking setup, see; http://hr.uoregon.edu/davidrl/Documentation/
echo "0" > /proc/sys/net/ipv4/ip_forward
echo "1" > /proc/sys/net/ipv4/conf/$INT/rp_filter
echo "0" > /proc/sys/net/ipv4/conf/$LOOP/rp_filter
echo "1" > /proc/sys/net/ipv4/conf/all/log_martians
echo "0" > /proc/sys/net/ipv4/conf/$LOOP/log_martians
echo 0 > /proc/sys/net/ipv4/tcp_timestamps
echo 1 > /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses
echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_all
echo "0" > /proc/sys/net/ipv4/conf/all/accept_source_route
echo "0" > /proc/sys/net/ipv4/conf/all/send_redirects
echo "0" > /proc/sys/net/ipv4/tcp_ecn
echo "1" > /proc/sys/net/ipv4/tcp_syncookies
echo "0" > /proc/sys/net/ipv4/conf/all/accept_redirects
echo "0" > /proc/sys/net/ipv4/conf/all/secure_redirects
# 128 MB of RAM -> 8192 possible entries, 256 MB of RAM --> 16376 possible entries, etc... 
echo 16184 > /proc/sys/net/ipv4/ip_conntrack_max
echo "1" > /proc/sys/net/ipv4/ip_dynaddr
echo 10 > /proc/sys/net/ipv4/tcp_fin_timeout
echo 1800 > /proc/sys/net/ipv4/tcp_keepalive_time
echo 0 > /proc/sys/net/ipv4/tcp_window_scaling
echo 0 > /proc/sys/net/ipv4/tcp_sack
echo 15 > /proc/sys/net/ipv4/ipfrag_time
echo 2048 > /proc/sys/net/ipv4/tcp_max_syn_backlog
echo "32768 61000" > /proc/sys/net/ipv4/ip_local_port_range
echo "2" > /proc/sys/net/ipv4/tcp_synack_retries
# Increase the amount of memory associated with input and output socket buffers
echo 262144 > /proc/sys/net/core/rmem_default
echo 262144 > /proc/sys/net/core/rmem_max
echo 262144 > /proc/sys/net/core/wmem_default
echo 262144 > /proc/sys/net/core/wmem_max

# Log and drop outgoing locally generated packets by time match
for i in $TIME; do
if [ $TIME == "y" ]
 then
if [ -f /lib/modules/`uname -r`/kernel/net/ipv4/netfilter/ipt_time.o ] 
 then
/sbin/modprobe ipt_time
  echo "dropping outgoing time match packets, days: $DAYS from $TIMESTART to $TIMESTOP..."
ipt -A OUTPUT -o $INT -m time --timestart $TIMESTART --timestop $TIMESTOP --days $DAYS -j LOG --log-level $LOGLEVEL --log-prefix "DROP time match packet: " -m limit --limit 45/m
ipt -A OUTPUT -o $INT -m time --timestart $TIMESTART --timestop $TIMESTOP --days $DAYS -j DROP
 else
printf "\033[1;60mipt_time module not found... local time match rules not used! \033[0m\n"
fi
fi
done

# Match two parameters that tell it the desired filtering interval in packets per second
for i in $FUZZY; do
if [ $FUZZY == "y" ]
 then
if [ -f /lib/modules/`uname -r`/kernel/net/ipv4/netfilter/ipt_fuzzy.o ] 
 then
/sbin/modprobe ipt_fuzzy
  echo "dropping fuzzy match packets between $LOWER and $UPPER pps..."
ipt -A INPUT -m fuzzy --lower-limit $LOWER --upper-limit $UPPER -j LOG --log-prefix "DROP fuzzy packet: " -m limit --limit 1/h
ipt -A INPUT -m fuzzy --lower-limit $LOWER --upper-limit $UPPER -j DROP
else
printf "\033[1;60mipt_fuzzy module not found... fuzzy match rules not used! \033[0m\n"
fi
fi
done

# Drop local uid match packets    
for i in $LAME_USER; do
if [ -f /lib/modules/`uname -r`/kernel/net/ipv4/netfilter/ipt_owner.o ] 
 then
/sbin/modprobe ipt_owner
  echo "no World Wide Waste for user $LAME_USER..."
ipt -A OUTPUT -m owner --uid-owner $LAME_UID -m limit --limit 1/h -j LOG --log-level $LOGLEVEL --log-prefix "DROP packet from $LAME_USER: " 
ipt -A OUTPUT -m owner --uid-owner $LAME_UID -j DROP
 else
printf "\033[1;60mipt_owner module not found... local uid match rules not used! \033[0m\n"
fi
done

# Match source/destination IP addresses against inclusive IP address ranges
for i in $IPRANGE; do
if [ -f /lib/modules/`uname -r`/kernel/net/ipv4/netfilter/ipt_iprange.o ]
 then
/sbin/modprobe ipt_iprange
  echo "dropping iprange source/destination $i..."
ipt -A INPUT -i $INT -m limit --limit 1/h -m iprange --src-range $i -j LOG --log-level $LOGLEVEL --log-prefix "DROP src range: "
ipt -A INPUT -i $INT -m iprange --src-range $i -j DROP
ipt -A OUTPUT -o $INT -m iprange --dst-range $i -j DROP
 else
printf "\033[1;60mipt_iprange module not found... iprange match rules not used! \033[0m\n"
fi
done

# DROP packets from connection which transfered more than FROM and less than TO bytes
for i in $CONN; do
if [ -f /lib/modules/`uname -r`/kernel/net/ipv4/netfilter/ipt_connbytes.o ]
 then
/sbin/modprobe ipt_connbytes
  echo "dropping connbytes match packets FROM:[TO] $CONN...."
ipt -A INPUT -i $INT -m connbytes --connbytes $CONN -m limit --limit 1/h -j LOG --log-level $LOGLEVEL --log-prefix "DROP connbyte packet: "
ipt -A INPUT -i $INT -m connbytes --connbytes $CONN -j DROP
 else
printf "\033[1;60mipt_connbytes module not found... connbytes match rules not used! \033[0m\n"
fi
done

# DROP, REJECT with "blah" or TARPIT string match packets
for i in $STRINGS; do
if [ $STRING == "d" ]
 then
if [ -f /lib/modules/`uname -r`/kernel/net/ipv4/netfilter/ipt_string.o ] 
 then
/sbin/modprobe ipt_string
  echo "dropping string match packets '$i' to tcp port $STRING_TCP_PORT...."
ipt -A INPUT -i $INT -p tcp --dport $STRING_TCP_PORT -m state --state ESTABLISHED -m limit --limit 1/h -m string --string $i -j LOG --log-level $LOGLEVEL --log-prefix "DROP '$i': "
ipt -A INPUT -i $INT -p tcp --dport $STRING_TCP_PORT -m state --state ESTABLISHED -m string --string $i -j DROP
fi
fi
if [ $STRING == "r" ]
 then
if [ -f /lib/modules/`uname -r`/kernel/net/ipv4/netfilter/ipt_string.o ] 
 then
/sbin/modprobe ipt_string
/sbin/modprobe ipt_REJECT
ipt -A OUTPUT -o $INT -m state --state RELATED -p tcp -j ACCEPT
ipt -A OUTPUT -o $INT -m state --state RELATED -p icmp -j ACCEPT
  echo "rejecting string match packets '$i' to tcp port $STRING_TCP_PORT with $REJECT..."
ipt -A INPUT -i $INT -p tcp --dport $STRING_TCP_PORT -m state --state ESTABLISHED -m limit --limit 1/h -m string --string $i -j LOG --log-level $LOGLEVEL --log-prefix "REJECT '$i': "
ipt -A INPUT -i $INT -p tcp --dport $STRING_TCP_PORT -m state --state ESTABLISHED -m string --string $i -j REJECT --reject-with $REJECT
fi
fi
if [ $STRING == "t" ]
 then
if [ -f /lib/modules/`uname -r`/kernel/net/ipv4/netfilter/ipt_TARPIT.o ] 
 then
/sbin/modprobe ipt_string
/sbin/modprobe ipt_TARPIT
  echo "tarpiting string match packets '$i' to tcp port $STRING_TCP_PORT..."
ipt -A INPUT -i $INT -p tcp --dport $STRING_TCP_PORT -m state --state ESTABLISHED -m limit --limit 1/h -m string --string $i -j LOG --log-level $LOGLEVEL --log-prefix "TARPIT '$i': "
ipt -A INPUT -i $INT -p tcp --dport $STRING_TCP_PORT -m state --state ESTABLISHED -m string --string $i -j TARPIT
else
printf "\033[1;60mipt_string/ipt_TARPIT module not found... TARPIT target rules not used! \033[0m\n"
fi
fi
done
# Delete duplicated rules, hide errors
ipt -D OUTPUT -o $INT -m state --state RELATED -p tcp -j ACCEPT 2>/dev/null >/dev/null
ipt -D OUTPUT -o $INT -m state --state RELATED -p icmp -j ACCEPT 2>/dev/null >/dev/null

# MIRROR target, Bounce the packet back to the sender
for i in $MIRROR_TCP_PORT; do
/sbin/modprobe ipt_MIRROR
printf "\033[1;60mmirror target for port ->$i tcp... \033[0m\n" 
ipt -A INPUT -i $INT -p tcp --dport $i -m limit --limit 25/m -j LOG --log-level $LOGLEVEL --log-prefix "MIRROR target: " 
ipt -A INPUT -t mangle -i $INT -p tcp --dport $i -j TTL --ttl-dec 2 
ipt -A INPUT -i $INT -p tcp --dport $i -j MIRROR 
done

# This match the second and third part of a fragmented packet, if this match is inversed, "!-f", we match all the first fragments of a fragmented packets, and all packets that has not been fragmented 
if [ $FPACKLOG == "y" ]
 then
  echo "logging fragmented packets..."
ipt -A INPUT -i $INT -f -s 0/0 -m limit --limit 2/m -j LOG --log-level $LOGLEVEL --log-prefix "DROP fragmented packet: " 
ipt -A INPUT -i $INT -f -s 0/0 -j DROP
fi

# Log and drop illegal combination of tcp flags/options  
ILIMIT="-m limit --limit 3/m"
if [ $BADTCPLOG == "y" ]
 then
  echo "logging illegal tcp flags/options packets..."
# ALL without FIN,URG,PSH bit set
ipt -A INPUT -i $INT -p tcp --tcp-flags ALL FIN,URG,PSH $ILIMIT -j LOG --log-level $LOGLEVEL --log-prefix "DROP illegal tcp flag: " 
# SYN and RST bits are both set
ipt -A INPUT -i $INT -p tcp --tcp-flags SYN,RST SYN,RST $ILIMIT -j LOG --log-level $LOGLEVEL --log-prefix "DROP illegall tcp flag: " 
# SYN and FIN bits are both set
ipt -A INPUT -i $INT -p tcp --tcp-flags SYN,FIN SYN,FIN $ILIMIT -j LOG --log-level $LOGLEVEL --log-prefix "DROP illegal tcp flag: " 
# ALL without FIN bit set
ipt -A INPUT -i $INT -p tcp --tcp-flags ALL FIN $ILIMIT -j LOG --log-level $LOGLEVEL --log-prefix "DROP illegal tcp flag: " 
# ALL without any bit set
ipt -A INPUT -i $INT -p tcp --tcp-flags ALL ALL $ILIMIT -j LOG --log-level $LOGLEVEL --log-prefix "DROP illegal tcp flag: " 
# ALL of the bits are cleared
ipt -A INPUT -i $INT -p tcp --tcp-flags ALL NONE $ILIMIT -j LOG --log-level $LOGLEVEL --log-prefix "DROP illegal tcp flag: "
# FIN and RST bit are both set
ipt -A INPUT -i $INT -p tcp --tcp-flags FIN,RST FIN,RST $ILIMIT -j LOG --log-level $LOGLEVEL --log-prefix "DROP illegal tcp flag: " 
# FIN without the ACK bit set
ipt -A INPUT -i $INT -p tcp --tcp-flags ACK,FIN FIN $ILIMIT -j LOG --log-level $LOGLEVEL --log-prefix "DROP illegal tcp flag: " 
# PSH without the ACK bit set
ipt -A INPUT -i $INT -p tcp --tcp-flags ACK,PSH PSH $ILIMIT -j LOG --log-level $LOGLEVEL --log-prefix "DROP illegal tcp flag: " 
# URG without the ACK bit set
ipt -A INPUT -i $INT -p tcp --tcp-flags ACK,URG URG $ILIMIT -j LOG --log-level $LOGLEVEL --log-prefix "DROP illegal tcp flag: " 
# Bad TCP option(64)
ipt -A INPUT -i $INT -p tcp --tcp-option 64 $ILIMIT -j LOG --log-level $LOGLEVEL --log-prefix "DROP bad tcp option(64): " 
# Bad TCP option(128)
ipt -A INPUT -i $INT -p tcp --tcp-option 128 $ILIMIT -j LOG --log-level $LOGLEVEL --log-prefix "DROP bad tcp option(128): "  
ipt -A INPUT -i $INT -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP
ipt -A INPUT -i $INT -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
ipt -A INPUT -i $INT -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP
ipt -A INPUT -i $INT -p tcp --tcp-flags ALL FIN -j DROP
ipt -A INPUT -i $INT -p tcp --tcp-flags ALL ALL -j DROP
ipt -A INPUT -i $INT -p tcp --tcp-flags ALL NONE -j DROP
ipt -A INPUT -i $INT -p tcp --tcp-flags FIN,RST FIN,RST -j DROP
ipt -A INPUT -i $INT -p tcp --tcp-flags ACK,FIN FIN -j DROP
ipt -A INPUT -i $INT -p tcp --tcp-flags ACK,PSH PSH -j DROP
ipt -A INPUT -i $INT -p tcp --tcp-flags ACK,URG URG -j DROP  
ipt -A INPUT -i $INT -p tcp --tcp-option 64 -j DROP 
ipt -A INPUT -i $INT -p tcp --tcp-option 128 -j DROP 
fi

# Allow only outgoing NEW and ESTABLISHED connections 
ipt -A OUTPUT -o $INT -m state --state NEW,ESTABLISHED -j ACCEPT
# Clamp MSS (Maximum Segment Size) to the PMTU (Path Maximum Transmit Unit), to counter ISPs and servers who block ICMP Fragmentation Needed packets (see kernel configuration help) 
ipt -t nat -A POSTROUTING -o $INT -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu
# Allow only ESTABLISHED connections
ipt -A INPUT -i $INT -m state --state ESTABLISHED -j ACCEPT
# For IRC dcc, and passive ftp mode behind the firewall
if [ $RELATED == "y" ]
 then 
  echo "connection tracking of related packets..."
ipt -A INPUT -i $INT -m state --state RELATED -j ACCEPT
fi

# IANA RESERVED IPv4 addresses, that should never come in from the internet. - http://www.iana.org/assignments/ipv4-address-space 
IANA_RESERVED="0 1 2 5 7 23 27 31 36 37 39 41 42 58 59 71 72 73 74 75 76 77 78 79 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 189 190 197 223 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255"
# LOG IANA RESERVED IPv4 addresses connection attempts
if [ $IANA == "y" ]
 then 
  echo "logging IANA RESERVED IPv4 addresses connection attempts..."
for LOOP_NETWORK in $IANA_RESERVED; do
ipt -t nat -A PREROUTING -i $INT -m limit --limit 1/h -s $LOOP_NETWORK.0.0.0/8 -j LOG --log-level $LOGLEVEL --log-prefix "DROP IANA RESERVED: "
done
fi
# DROP IANA RESERVED IPv4 addresses connection attempts
for LOOP_NETWORK in $IANA_RESERVED; do
ipt -t nat -A PREROUTING -i $INT -s $LOOP_NETWORK.0.0.0/8 -j DROP      
done

# IANA Special-Use IPv4 addresses - http://www.rfc-editor.org/rfc/rfc3330.txt
IANA_SPECIAL_USE="10 14"
# LOG Special-Use IPv4 addresses space connection attempts
SLIMIT="-m limit --limit 1/h"
if [ $IANA == "y" ]
 then 
  echo "logging IANA Special-Use IPv4 addresses connection attempts..."
for LOOP_NETWORK in $IANA_SPECIAL_USE; do
ipt -t nat -A PREROUTING -i $INT $SLIMIT -s $LOOP_NETWORK.0.0.0/8 -j LOG --log-level $LOGLEVEL --log-prefix "DROP IANA Special-Use: " 
done 
ipt -t nat -A PREROUTING -i $INT $SLIMIT -s 128.0.0.0/16 -j LOG --log-level $LOGLEVEL --log-prefix "DROP IANA Special-Use: " 
ipt -t nat -A PREROUTING -i $INT $SLIMIT -s 169.254.0.0/16 -j LOG --log-level $LOGLEVEL --log-prefix "DROP IANA Special-Use: "  
ipt -t nat -A PREROUTING -i $INT $SLIMIT -s 172.16.0.0/12 -j LOG --log-level $LOGLEVEL --log-prefix "DROP IANA Special-Use: "    
ipt -t nat -A PREROUTING -i $INT $SLIMIT -s 191.255.0.0/16 -j LOG --log-level $LOGLEVEL --log-prefix "DROP IANA Special-Use: "    
   
ipt -t nat -A PREROUTING -i $INT $SLIMIT -s 192.0.0.0/24 -j LOG --log-level $LOGLEVEL --log-prefix "DROP IANA Special-Use: "       
ipt -t nat -A PREROUTING -i $INT $SLIMIT -s 192.0.2.0/24 -j LOG --log-level $LOGLEVEL --log-prefix "DROP IANA Special-Use: "      
ipt -t nat -A PREROUTING -i $INT $SLIMIT -s 192.88.99.0/24 -j LOG --log-level $LOGLEVEL --log-prefix "DROP IANA Special-Use: "   
ipt -t nat -A PREROUTING -i $INT $SLIMIT -s 192.168.0.0/16 -j LOG --log-level $LOGLEVEL --log-prefix "DROP IANA Special-Use: "   
ipt -t nat -A PREROUTING -i $INT $SLIMIT -s 198.18.0.0/15 -j LOG --log-level $LOGLEVEL --log-prefix "DROP IANA Special-Use: "  
ipt -t nat -A PREROUTING -i $INT $SLIMIT -s 224.0.0.0/4 -j LOG --log-level $LOGLEVEL --log-prefix "DROP IANA Special-Use: " 
ipt -t nat -A PREROUTING -i $INT $SLIMIT -s 240.0.0.0/4 -j LOG --log-level $LOGLEVEL --log-prefix "DROP IANA Special-Use: "      
fi
# Network interface ip address          
ipt -t nat -A PREROUTING -i $INT -m limit --limit 1/h -s $IP_ADDR -j LOG --log-level $LOGLEVEL --log-prefix "DROP $IP_ADDR on $INT: "
        
for LOOP_NETWORK in $IANA_SPECIAL_USE; do
ipt -t nat -A PREROUTING -i $INT -s $LOOP_NETWORK.0.0.0/8 -j DROP
done  
ipt -t nat -A PREROUTING -i $INT -s 128.0.0.0/16 -j DROP   
ipt -t nat -A PREROUTING -i $INT -s 169.254.0.0/16 -j DROP     
ipt -t nat -A PREROUTING -i $INT -s 172.16.0.0/12 -j DROP          
ipt -t nat -A PREROUTING -i $INT -s 191.255.0.0/16 -j DROP           
ipt -t nat -A PREROUTING -i $INT -s 192.0.0.0/24 -j DROP        
ipt -t nat -A PREROUTING -i $INT -s 192.0.2.0/24 -j DROP        
ipt -t nat -A PREROUTING -i $INT -s 192.88.99.0/24 -j DROP     
ipt -t nat -A PREROUTING -i $INT -s 192.168.0.0/16 -j DROP     
ipt -t nat -A PREROUTING -i $INT -s 198.18.0.0/15 -j DROP      
ipt -t nat -A PREROUTING -i $INT -s 224.0.0.0/4 -j DROP 
ipt -t nat -A PREROUTING -i $INT -s 240.0.0.0/4 -j DROP       
ipt -t nat -A PREROUTING -i $INT -s $IP_ADDR -j DROP        
# My cable modem static ip address; 192.168.100.1 and btw, dont forget to change your default cable modem login and password
ipt -t nat -A PREROUTING -m limit --limit 1/h ! -i $LOOP -d 192.168.0.0/16 -j LOG --log-level $LOGLEVEL --log-prefix "DROP cable modem access? :"
ipt -t nat -A PREROUTING ! -i $LOOP -d 192.168.0.0/16 -j DROP 
# My cable modem static "backdoor" ip address?!?, sh-2.05$ snmpwalk  192.168.100.1 public| grep "IpAddress: 10.18.*" (damn vendors they are all alike!)
ipt -t nat -A PREROUTING -m limit --limit 1/h ! -i $LOOP -d 10.18.0.0/16 -j LOG --log-level $LOGLEVEL --log-prefix "DROP cable modem access? :"
ipt -t nat -A PREROUTING ! -i $LOOP -d 10.18.0.0/16 -j DROP
# Drop outgoing spoofed packets 
ipt -t nat -A POSTROUTING -o $INT -m limit --limit 1/h ! -s $IP_ADDR -j LOG --log-level $LOGLEVEL --log-prefix "DROP spoofed packet: "  
ipt -t nat -A POSTROUTING -o $INT ! -s $IP_ADDR -j DROP 

# Log connection attempts to explicitly closed tcp ports 
for i in $CLOSEDTCP; do
  echo "logging connection attempts to tcp port $i..."
ipt -A INPUT -i $INT -p tcp -m limit --limit 3/m --dport $i -j LOG --log-level $LOGLEVEL --log-prefix "DROP closed tcp violation: " --log-tcp-options  --log-ip-options --log-tcp-sequence
ipt -A INPUT -i $INT -p tcp --dport $i -j DROP
done

# Log connection attempts to explicitly closed udp ports
for i in $CLOSEDUDP; do
  echo "logging connection attempts to udp port $i..."
ipt -A INPUT -i $INT -p udp -m limit --limit 3/m --dport $i -j LOG --log-level $LOGLEVEL --log-prefix "DROP closedudp violation: "
ipt -A INPUT -i $INT -p udp --dport $i -j DROP
done

# Log connection attempts from explicitly blocked hosts
if [ $BLOCKHOSTSLOG == "y" ]
 then 
for i in $BLOCKHOSTS; do
  echo "logging connection attempts from $i..."
ipt -I INPUT -i $INT -m limit --limit 25/m -s $i -j LOG --log-level $LOGLEVEL --log-prefix "DROP blockhosts violation: "
done
fi

# Log connection attempts from explicitly blocked networks
if [ $BLOCKNETLOG == "y" ]
 then 
for i in $BLOCKNET; do
  echo "logging connection attempts from $i..."
ipt -I INPUT -i $INT -m limit --limit 25/m -s $i -j LOG --log-level $LOGLEVEL --log-prefix "DROP blocknet violation: "
done
fi

# Note: dropping the route to the host(s) via kernel ip routing table, doesn't LOG any packet sent by the blocked host(s), but the kernel will LOG martians...(?!?)
for i in $BLOCKHOSTS; do
  echo "host $i blocked..."
ipt -I INPUT 2 -i $INT -s $i -j DROP
ipt -I OUTPUT 2 -o $INT -d $i -j DROP
#/sbin/route add -host $i reject 2>/dev/null >/dev/null 
done
for i in $BLOCKNET; do
  echo "network $i blocked..."
ipt -I INPUT 2 -i $INT -s $i -j DROP
ipt -I OUTPUT 2 -o $INT -d $i -j DROP
#/sbin/route add -net $i reject 2>/dev/null >/dev/null
done

# "Strange, unwanted, malformed packets - abandoned and doomed freaks of nature - as we, mere mortals, meet them on twisted paths of our grand journey called life." from: http://lcamtuf.coredump.cx/mobp/ - the museum of broken packets
if [ $MPACKLOG == "y" ] 
 then
/sbin/modprobe ipt_unclean
  echo "logging malformed packets..."
ipt -A INPUT -i $INT -m unclean -m limit --limit 2/m -j LOG --log-level $LOGLEVEL --log-prefix "DROP malformed packet: "
ipt -A INPUT -i $INT -m unclean -j DROP
fi

# Some bad TCP/IP implementation or bad MS$ products  
if [ $NNSYNLOG == "y" ]
 then
  echo "logging new packets with no syn flag set..."
ipt -A INPUT -i $INT -p tcp ! --syn -m state --state NEW -m limit --limit 1/h -j LOG --log-prefix "DROP new not syn: "
ipt -A INPUT -i $INT -p tcp ! --syn -m state --state NEW -j DROP
fi

# ICMP has been used for scanning, Denial of Service (DoS) attacks, tunneling 
if [ $ICMPLOG == "y" ]
 then
  echo "logging icmp packets..."
ipt -A INPUT -i $INT -p icmp -m limit --limit 1/h -j LOG --log-level $LOGLEVEL --log-prefix "DROP icmp packet: " 
ipt -A INPUT -i $INT -p icmp -j DROP
fi

# IGMP has been used mostly for wrong purposes
if [ $IGMPLOG == "y" ]
 then
  echo "logging igmp packets..."
ipt -A INPUT -i $INT -p igmp -m limit --limit 2/m -j LOG --log-level $LOGLEVEL --log-prefix "DROP igmp packet: " 
ipt -A INPUT -i $INT -p igmp -j DROP
fi

# Portscan detection match
WEIGHT="--psd-weight-threshold=10"  #Portscan detection weight threshold
DELAY="--psd-delay-threshold=300"   #Portscan detection delay threshold
LO="--psd-lo-ports-weight=2"        #Privileged ports weight
HI="--psd-hi-ports-weight=1"        #High ports weight
if [ $PSD == "y" ] 
 then
if [ -f /lib/modules/`uname -r`/kernel/net/ipv4/netfilter/ipt_psd.o ] 
 then
/sbin/modprobe ipt_psd
  echo "logging portscan detection match packets: $WEIGHT, $DELAY, $LO, $HI..."
ipt -A INPUT -i $INT -m psd -m limit $WEIGHT $DELAY $LO $HI --limit 1/h -j LOG --log-level $LOGLEVEL --log-prefix "DROP portscan match: " 
ipt -A INPUT -i $INT -m psd $WEIGHT $DELAY $LO $HI -j DROP
 else
printf "\033[1;60mipt_psd module not found... portscan detection match rules not used! \033[0m\n"
fi
fi

# Maybe harmless packets that came in after netfilter's timeout, maybe a form of detecting a filtered host, or some kind of advanced host detection technique  
if [ $IPACKLOG == "y" ]
 then
  echo "logging invalid packets..."
ipt -A INPUT -i $INT -p tcp -m state --state INVALID -m limit --limit 3/m -j LOG --log-level $LOGLEVEL --log-prefix "DROP invalid packet: "
ipt -A INPUT -i $INT -p tcp -m state --state INVALID -j DROP
fi

# Open tcp ports/services to the WWW with quota options
for i in $OPEN_TCP_QUOTA; do
if [ -f /lib/modules/`uname -r`/kernel/net/ipv4/netfilter/ipt_quota.o ] 
 then
/sbin/modprobe ipt_quota
  printf "\033[1;60madding open port ->$i tcp with $QUOTA bytes quota...\033[0m\n" 
ipt -A INPUT -i $INT -p tcp --syn -m state --state NEW -m limit --limit 2/s --dport $i -m quota --quota $QUOTA -j ACCEPT
ipt -A INPUT -i $INT -p tcp --dport $i -j DROP
 else
printf "\033[1;60mipt_quota module not found... quota option rules not used! \033[0m\n"
fi
done
# Open udp ports/services to the WWW with quota options
for i in $OPEN_UDP_QUOTA; do
if [ -f /lib/modules/`uname -r`/kernel/net/ipv4/netfilter/ipt_quota.o ] 
 then
/sbin/modprobe ipt_quota
  printf "\033[1;60madding open port ->$i udp with $QUOTA bytes quota...\033[0m\n" 
ipt -A INPUT -i $INT -p udp -m state --state NEW -m limit --limit 2/s --dport $i -m quota --quota $QUOTA -j ACCEPT
ipt -A INPUT -i $INT -p udp --dport $i -j DROP
 else
printf "\033[1;60mipt_quota module not found... quota option rules not used! \033[0m\n"
fi
done

# Accept only NEW packets with the SYN flag set, drop all the rest. There is also a connlimit-above "n" to limit the number of existing tcp parallel connections from a single host (or group hosts using mask --connlimit -mask "n") to "number".
for i in $OPEN_TCP; do
  printf "\033[1;60madding open port ->$i tcp...\033[0m\n" 
if [ -f /lib/modules/`uname -r`/kernel/net/ipv4/netfilter/ipt_connlimit.o ] 
 then
/sbin/modprobe ipt_connlimit
# Limit the number of parallel connections made by group hosts using mask
#echo "limiting to '3' the number of connections from 213.22.0.0/16 to tcp port $i..."
#ipt -A INPUT -i $INT -p tcp --syn --dport $i -m connlimit --connlimit-above 3 --connlimit-mask 213.22.0.0/16 -j DROP
  echo "limiting to '$LIMIT' the number of connections from a single host to tcp port $i..."
ipt -A INPUT -i $INT -p tcp --syn --dport $i -m connlimit --connlimit-above $LIMIT -j DROP
ipt -A INPUT -i $INT -p tcp --syn -m state --state NEW -m limit --limit 2/s --dport $i -j ACCEPT
 else
ipt -A INPUT -i $INT -p tcp --syn -m state --state NEW -m limit --limit 2/s --dport $i -j ACCEPT
printf "\033[1;60mipt_connlimit module not found... tcp connections limit rules not used! \033[0m\n"
fi
done

# Open udp ports/servics to the WWW  
for i in $OPEN_UDP; do
  printf "\033[1;60madding open port ->$i udp...\033[0m\n" 
ipt -A INPUT -i $INT -p udp -m state --state NEW -m limit --limit 2/s --dport $i -j ACCEPT
done

# Match packets based on the IP options they have 
for i in $IPV4_OPTIONS; do
if [ -f /lib/modules/`uname -r`/kernel/net/ipv4/netfilter/ipt_ipv4options.o ]
 then
/sbin/modprobe ipt_ipv4options
  echo "logging ipv4options match '$i'..."
ipt -A INPUT -i $INT -m limit --limit 1/h -m ipv4options $i -j LOG --log-prefix "DROP ipv4options match: "
 else
printf "\033[1;60mipt_ipv4options module not found... ipv4options type rules not used! \033[0m\n"
fi
done

# Remote trusted host tcp port access
for i in $TRUST_HOST; do
  printf "\033[1;60madding access to port ->$TH_TCP_PORT tcp from $i...\033[0m\n" 
ipt -A INPUT -i $INT -p tcp -m state --state NEW -m limit --limit 3/s -s $TRUST_HOST --dport $TH_TCP_PORT -j ACCEPT
done

# Match a packet based on its type: (to us, to all, to group)
for i in $PKT_TYPE; do
if [ -f /lib/modules/`uname -r`/kernel/net/ipv4/netfilter/ipt_pkttype.o ]
 then
/sbin/modprobe ipt_pkttype
  echo "logging pkttype match '$i'..."
ipt -A INPUT -i $INT -m limit --limit 1/h -m pkttype --pkt-type $i -j LOG --log-prefix "DROP pkttype match: "
ipt -A INPUT -i $INT -m limit -m pkttype --pkt-type $i -j DROP
else
printf "\033[1;60mipt_pkttype module not found... packet type rules not used! \033[0m\n"
fi
done

for i in $IPV4_OPTIONS; do
ipt -A INPUT -i $INT -m ipv4options $i -j DROP 2>/dev/null >/dev/null
done

# Set the TTL of all outgoing connections to "n", (If you know what OS is running on it, see http://www.insecure.org/cgi-bin/nmap-submit.cgi). :p
# See: http://project.honeynet.org/papers/finger/traces.txt 
if [ -f /lib/modules/`uname -r`/kernel/net/ipv4/netfilter/ipt_TTL.o ] 
 then
/sbin/modprobe ipt_TTL
ipt -t mangle -o $INT -A OUTPUT -j TTL --ttl-set $TTL_SET
 else
printf "\033[1;60mipt_TTL module not found... ttl value not set! \033[0m\n"
fi
 
# Tell the TOS (Type Of Service) mangler, what values to set to the matched packets (RFC 1060/1349)
if [ "$MANGLE" = "y" ] ; then
  echo  "setting mangle output ToS options to ports 20,21:23,25,53,80 tcp, 53 udp..."
ipt -t mangle -A OUTPUT -p tcp -o $INT --dport 20 -j TOS --set-tos 8
ipt -t mangle -A OUTPUT -p tcp -o $INT --dport 21:23 -j TOS --set-tos 16
ipt -t mangle -A OUTPUT -p tcp -o $INT --dport 25 -j TOS --set-tos 16
ipt -t mangle -A OUTPUT -p tcp -o $INT --dport 53 -j TOS --set-tos 8
ipt -t mangle -A OUTPUT -p udp -o $INT --dport 53 -j TOS --set-tos 16
ipt -t mangle -A OUTPUT -p tcp -o $INT --dport 80 -j TOS --set-tos 16
  echo "setting mangle prerouting ToS options to ports 20,21:23,25,53,80 tcp, 53 udp..."
ipt -t mangle -A PREROUTING -p tcp -i $INT --sport 20 -j TOS --set-tos 8
ipt -t mangle -A PREROUTING -p tcp -i $INT --sport 21:23 -j TOS --set-tos 16
ipt -t mangle -A PREROUTING -p tcp -i $INT --sport 25 -j TOS --set-tos 16
ipt -t mangle -A PREROUTING -p tcp -i $INT --sport 53 -j TOS --set-tos 8
ipt -t mangle -A PREROUTING -p udp -i $INT --sport 53 -j TOS --set-tos 16
ipt -t mangle -A PREROUTING -p tcp -i $INT --sport 80 -j TOS --set-tos 16
fi

# Remove all unnused modules, hide errors
/sbin/rmmod `/bin/cat /proc/modules|/bin/grep "ip_*" |/bin/cut -d ' ' -f1` 2>/dev/null >/dev/null
/sbin/rmmod `/bin/cat /proc/modules|/bin/grep 'ipt_*' |/bin/cut -d ' ' -f1` 2>/dev/null >/dev/null
/sbin/rmmod `/bin/cat /proc/modules|/bin/grep 'iptable_*' |/bin/cut -d ' ' -f1` 2>/dev/null >/dev/null
if [ $RELATED == "y" ]
 then 
/sbin/modprobe ip_conntrack_ftp
/sbin/modprobe ip_conntrack_irc 
fi
}

stop () { 
ipt -F
ipt -Z
ipt -X
ipt -F -t nat  
ipt -Z -t nat
ipt -X -t nat 
ipt -t nat -P PREROUTING ACCEPT
ipt -t nat -P POSTROUTING ACCEPT
ipt -t nat -P OUTPUT ACCEPT
ipt -F -t mangle 
ipt -Z -t mangle
ipt -X -t mangle 
ipt -t mangle -P PREROUTING ACCEPT
ipt -t mangle -P OUTPUT ACCEPT
ipt -t mangle -P INPUT ACCEPT 2>/dev/null >/dev/null
ipt -t mangle -P FORWARD DROP 2>/dev/null >/dev/null
ipt -t mangle -P POSTROUTING ACCEPT 2>/dev/null >/dev/null
ipt -P INPUT ACCEPT
ipt -P OUTPUT ACCEPT
ipt -P FORWARD DROP
#for i in $BLOCKHOSTS; do
#/sbin/route del -host $i reject 2>/dev/null >/dev/null
#done
#for i in $BLOCKNET; do
#/sbin/route del -net $i reject 2>/dev/null >/dev/null
#done 
}

# List filter (default) table
stat () {
printf "\033[1;60m---- filter table ----------\033[0m\n"
ipt --line-numbers -nvxL
}

# List nat table
nstat () {
printf "\033[1;60m---- nat table ----------\033[0m\n"
ipt -t nat --line-numbers -nvxL
}

# List mangle table
mstat () {
printf "\033[1;60m---- mangle table ----------\033[0m\n"
ipt -t mangle --line-numbers -nvxL
}

# Pull the plug (panic button, USE WITH CAUTION! :p) 
pulltheplug () {
ipt -F
ipt -F -t nat  
ipt -X -t nat 
ipt -t nat -P PREROUTING DROP
ipt -t nat -P POSTROUTING DROP
ipt -t nat -P OUTPUT DROP
ipt -F -t mangle 
ipt -X -t mangle 
ipt -t mangle -P PREROUTING DROP
ipt -t mangle -P OUTPUT DROP 
ipt -t mangle -P FORWARD DROP 2>/dev/null >/dev/null 
ipt -t mangle -P INPUT DROP 2>/dev/null >/dev/null
ipt -t mangle -P POSTROUTING DROP 2>/dev/null >/dev/null
ipt -P INPUT DROP
ipt -P OUTPUT DROP
ipt -P FORWARD DROP
/sbin/dhcpcd -k 2>/dev/null >/dev/null                                 
/sbin/ifconfig $INT down                         
/sbin/route add -net 0.0.0.0/0 reject 2>/dev/null >/dev/null
printf "\033[1;60mNetwork is down! \033[0m\n" 
.   $LARTC lstop
.   $LARTC lstat
}

pushtheplug () {
/sbin/route del -net 0.0.0.0/0 reject 2>/dev/null >/dev/null
/sbin/ifconfig $INT up
/sbin/dhcpcd -R -d -n $INT 2>/dev/null >/dev/null
     reload 2>/dev/null >/dev/null
printf "\033[1;60mNetwork is up! (hopefully)...\033[0m\n"
}

# Minimal ruleset
basic () {
     stop 2>/dev/null >/dev/null
# To spoof or not to spoof that is the question...
  echo "0" > /proc/sys/net/ipv4/conf/all/rp_filter
ipt -P INPUT DROP
ipt -P OUTPUT ACCEPT
ipt -P FORWARD DROP
ipt -A INPUT -i $LOOP -j ACCEPT
ipt -A INPUT -i $INT -m state --state ESTABLISHED -j ACCEPT
ipt -A INPUT -i $INT -j DROP
/sbin/rmmod `/bin/cat /proc/modules|/bin/grep "ip_*" |/bin/cut -d ' ' -f1` 2>/dev/null >/dev/null
/sbin/rmmod `/bin/cat /proc/modules|/bin/grep 'ipt_*' |/bin/cut -d ' ' -f1` 2>/dev/null >/dev/null
/sbin/rmmod `/bin/cat /proc/modules|/bin/grep 'iptable_*' |/bin/cut -d ' ' -f1` 2>/dev/null >/dev/null
.   $LARTC lstop
}

reload () {
if [ "`ipt -t mangle -L |grep 0x1`" ]
 then
    stop 2>/dev/null >/dev/null
    start 
.   $LARTC lstart
 else
    stop 2>/dev/null >/dev/null
    start
fi 
}

case "$1" in
start)
if [ "`ipt -t mangle -L |grep 0x1`" ]
 then
    start
.   $LARTC lstart
 else
    start
fi;;

stop)
    cat
    stop
printf "\033[1;60mextremist firewall stopped...  \033[0m\n"
.   $LARTC lstop 2>/dev/null >/dev/null
.   $LARTC lstat;;

stat)
    stat;;

nstat)
    nstat;;

mstat)
    mstat;;

reload)
    reload;;

basic)
    cat
    basic;;

pulltheplug)
    cat
    pulltheplug
.   $LARTC lstop 2>/dev/null >/dev/null;;

pushtheplug)
    cat
    pushtheplug;;

lstart)
.   $LARTC lstart;; 

lstop)
.   $LARTC lstop;;

lstat)
.   $LARTC lstat;;

shaper)
.   $LARTC shaper;;
* )
   cat
  echo "Usage: $0 {start|stop|stat|nstat|mstat|reload|basic|pulltheplug|pushtheplug|lstart|lstop|lstat|shaper}"
exit 1
esac

exit $?

